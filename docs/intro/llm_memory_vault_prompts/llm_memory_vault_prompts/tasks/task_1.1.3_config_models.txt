# TASK 1.1.3: Create Configuration Models

## Context
Need type-safe configuration management with validation, defaults, and environment variable support.

## Your Role
You are a configuration architect expert in Pydantic and environment-based config management.

## Objective
Create `vault/config/models.py` with Pydantic models for all configuration sections.

## Instructions

### 1. Create vault/config/models.py

```python
"""
Configuration models for LLM Memory Vault.

All configuration is managed through Pydantic models with:
- Type validation
- Default values
- Environment variable overrides
- Nested configuration support
"""

from pathlib import Path
from typing import Optional
from pydantic import BaseModel, Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class DatabaseConfig(BaseModel):
    """SQLite database configuration."""
    
    db_path: Path = Field(
        default=Path("vault_data/vault.db"),
        description="Path to SQLite database file"
    )
    echo: bool = Field(
        default=False,
        description="Echo SQL statements (debug mode)"
    )
    pool_size: int = Field(
        default=5,
        description="Connection pool size"
    )
    
    @field_validator('db_path')
    @classmethod
    def ensure_parent_exists(cls, v: Path) -> Path:
        """Ensure parent directory exists."""
        v.parent.mkdir(parents=True, exist_ok=True)
        return v


class BlobConfig(BaseModel):
    """Encrypted blob storage configuration."""
    
    blob_root: Path = Field(
        default=Path("vault_data/blobs"),
        description="Root directory for encrypted blobs"
    )
    compression: bool = Field(
        default=True,
        description="Compress blobs before encryption"
    )
    max_blob_size_mb: int = Field(
        default=100,
        description="Maximum blob size in MB"
    )
    
    @field_validator('blob_root')
    @classmethod
    def ensure_exists(cls, v: Path) -> Path:
        """Ensure blob directory exists."""
        v.mkdir(parents=True, exist_ok=True)
        return v


class SecurityConfig(BaseModel):
    """Security and encryption configuration."""
    
    argon2_time_cost: int = Field(
        default=4,
        description="Argon2 time cost parameter"
    )
    argon2_memory_cost: int = Field(
        default=65536,  # 64MB
        description="Argon2 memory cost in KB"
    )
    argon2_parallelism: int = Field(
        default=4,
        description="Argon2 parallelism factor"
    )
    session_expiry_minutes: int = Field(
        default=30,
        description="Session token expiry time"
    )
    salt_file: Path = Field(
        default=Path("vault_data/.salt"),
        description="Path to salt file"
    )
    session_file: Path = Field(
        default=Path("vault_data/.session"),
        description="Path to session token file"
    )


class VectorConfig(BaseModel):
    """Vector database configuration."""
    
    qdrant_url: str = Field(
        default="http://localhost:6333",
        description="Qdrant server URL"
    )
    collection_name: str = Field(
        default="conversations",
        description="Vector collection name"
    )
    vector_size: int = Field(
        default=384,  # all-MiniLM-L6-v2 size
        description="Embedding vector dimension"
    )
    enable_local: bool = Field(
        default=True,
        description="Use local Qdrant (vs remote server)"
    )


class APIConfig(BaseModel):
    """API server configuration."""
    
    host: str = Field(
        default="127.0.0.1",
        description="API server host"
    )
    port: int = Field(
        default=8000,
        description="API server port"
    )
    reload: bool = Field(
        default=False,
        description="Auto-reload on code changes"
    )
    workers: int = Field(
        default=1,
        description="Number of worker processes"
    )


class VaultConfig(BaseSettings):
    """Main vault configuration with environment variable support."""
    
    model_config = SettingsConfigDict(
        env_prefix="VAULT_",
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )
    
    # Root configuration
    vault_root: Path = Field(
        default=Path("vault_data"),
        description="Root directory for all vault data"
    )
    
    # Sub-configurations
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
    blobs: BlobConfig = Field(default_factory=BlobConfig)
    security: SecurityConfig = Field(default_factory=SecurityConfig)
    vectors: VectorConfig = Field(default_factory=VectorConfig)
    api: APIConfig = Field(default_factory=APIConfig)
    
    # Logging
    log_level: str = Field(
        default="INFO",
        description="Logging level (DEBUG, INFO, WARNING, ERROR)"
    )
    log_file: Optional[Path] = Field(
        default=None,
        description="Optional log file path"
    )
    
    @field_validator('vault_root')
    @classmethod
    def ensure_vault_root_exists(cls, v: Path) -> Path:
        """Ensure vault root directory exists."""
        v.mkdir(parents=True, exist_ok=True)
        return v
    
    def save(self, path: Path) -> None:
        """Save configuration to YAML file."""
        import yaml
        with open(path, 'w') as f:
            yaml.dump(self.model_dump(), f, default_flow_style=False)
    
    @classmethod
    def load(cls, path: Path) -> "VaultConfig":
        """Load configuration from YAML file."""
        import yaml
        with open(path, 'r') as f:
            data = yaml.safe_load(f)
        return cls(**data)


# Default configuration instance
def get_default_config() -> VaultConfig:
    """Get default configuration with all defaults applied."""
    return VaultConfig()
```

### 2. Create vault/config/loader.py

```python
"""Configuration loader utilities."""

from pathlib import Path
from typing import Optional
from .models import VaultConfig


_config_cache: Optional[VaultConfig] = None


def load_config(config_path: Optional[Path] = None) -> VaultConfig:
    """
    Load vault configuration from file or environment.
    
    Priority:
    1. Explicit config file path
    2. Environment variables (VAULT_*)
    3. Default values
    
    Args:
        config_path: Optional path to config YAML file
    
    Returns:
        VaultConfig instance
    """
    global _config_cache
    
    if _config_cache is not None:
        return _config_cache
    
    if config_path and config_path.exists():
        _config_cache = VaultConfig.load(config_path)
    else:
        _config_cache = VaultConfig()
    
    return _config_cache


def reset_config() -> None:
    """Reset cached configuration (useful for testing)."""
    global _config_cache
    _config_cache = None
```

### 3. Update vault/config/__init__.py

```python
"""
Configuration management for LLM Memory Vault.

Provides type-safe configuration with validation and environment variable support.
"""

from .models import (
    VaultConfig,
    DatabaseConfig,
    BlobConfig,
    SecurityConfig,
    VectorConfig,
    APIConfig,
    get_default_config,
)
from .loader import load_config, reset_config

__all__ = [
    "VaultConfig",
    "DatabaseConfig",
    "BlobConfig",
    "SecurityConfig",
    "VectorConfig",
    "APIConfig",
    "get_default_config",
    "load_config",
    "reset_config",
]
```

### 4. Test Configuration

Create a simple test script to verify:

```python
# test_config.py
from vault.config import VaultConfig, load_config
import os

# Test 1: Default configuration
config = VaultConfig()
print(f"Default vault root: {config.vault_root}")
print(f"Database path: {config.database.db_path}")
print(f"Session expiry: {config.security.session_expiry_minutes} minutes")

# Test 2: Environment variable override
os.environ["VAULT_VAULT_ROOT"] = "/tmp/test_vault"
config = VaultConfig()
print(f"Overridden vault root: {config.vault_root}")

# Test 3: Save and load
config.save(Path("test_config.yaml"))
loaded = VaultConfig.load(Path("test_config.yaml"))
assert loaded.vault_root == config.vault_root
print("✓ Save/load works")

# Cleanup
Path("test_config.yaml").unlink()
```

## Safety Constraints
- ✅ All paths validated and created if needed
- ✅ Secure defaults (strong Argon2 parameters)
- ✅ No hardcoded secrets
- ✅ Environment variable support for deployment

## Acceptance Criteria
- [ ] All config models defined with proper types
- [ ] Environment variable overrides work (VAULT_* prefix)
- [ ] Can load config from YAML file
- [ ] Can save config to YAML file
- [ ] Default values are secure and sensible
- [ ] Validation catches invalid configs
- [ ] Type hints complete
- [ ] Can import: `from vault.config import VaultConfig, load_config`

## Output Format
Create the three files as specified:
1. vault/config/models.py
2. vault/config/loader.py
3. vault/config/__init__.py (updated)

## Next Task
Task 1.1.4 will setup pre-commit hooks for code quality.
